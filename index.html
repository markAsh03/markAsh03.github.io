<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>MarkAsh Blog</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
</head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link">
                首页
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                标签
            </a>
            

            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">John Doe's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/06/21/Java虚拟机/"></a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-06-21</span>
                
            </div>
            <div class="post-content">
                
                    <h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ul>
<li>线程私有的：<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
<li>线程共享的：<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存   </li>
</ul>
</li>
</ul>
<p><img src="https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67" alt="image"></p>
<h5 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h5><ul>
<li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理， 线程恢复等功能都需要依赖这个计时器来完成。</li>
<li>程序计数器主要有两个作用：<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>
<li>多线程下，用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到了哪里。<h5 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h5></li>
</ul>
</li>
<li>其生命周期和线程相同，即Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</li>
<li>Java内存可以大概的分为堆内存heap和栈内存stack，其中栈就是虚拟机栈，或者是虚拟机栈中局部变量表部分。（实际上Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表，操作数栈，动态链表，方法出口信息）</li>
<li>局部变量表主要存放了编译器可知的各数据类型，对象引用（reference类型，他可能是一个指向对象起始地址的引用指针，也可能是指向一个代码对象的句柄或其他与此对象相关的位置）</li>
<li>Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError<ul>
<li>StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就会抛出StackOverFlowError。</li>
<li>OutOfMemoryError：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法动态扩展了，就会跑出OutOfMemoryError异常。</li>
</ul>
</li>
<li>Java虚拟机是线程私有的，每个线程都有自己的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li>
<li>方法、函数如何调用？<ul>
<li>Java栈可用类比数据结构总的栈，Java栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。<h5 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h5></li>
</ul>
</li>
<li>和虚拟机栈作用类似，区别是：虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在HotSpot虚拟机中和Java 虚拟机栈合二为一。</li>
</ul>
<h5 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h5><p>Java虚拟机管理内存中最大的一块，Java堆里所有线程共享的一块内存区域，在虚拟机启动时创建。此区域主要存放对象实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eden --&gt; s0 --&gt; s1 --&gt; Tentired</span><br></pre></td></tr></table></figure></p>
<p>上图所示Eden区，s0，s1区都是新生代，tentired区属于老生代，大部分情况下，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加1，当它的年龄增加到一定程度（默认15岁），就会晋升为老生代中，对于老生代阈值，可通过参数<code>-XX:MaxTenuringThreshold</code>配置</p>
<h5 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h5><ul>
<li>方法区与Java堆一样，是各个线程共享的内存区域，用于存放已被虚拟机加载的类信息，常量，静态变量，即是编译器编译后的代码等数据。还有一个别名Non-Heap（非堆）</li>
<li>方法区也被称为永久代，其实方法区是Java虚拟机规范的定义，是一种规范。而永久代是一种实现，是HotSpot堆方法区的一种实现，其他虚拟机实现并没有永久代这种概念。</li>
<li><p>JDK1.8之前，可通过以下参数调节方法区的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N // 方法区初始大小</span><br><span class="line">-XX:MaxPermSize=N // 方法区最大大小，超过这个值，将会跑出OutOfMemoryError异常</span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK1.8的时候，方法区被移除了，取而代之的是元空间，元空间使用的是直接内存</p>
</li>
<li>常用参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N // 设置Metaspace的初始代销</span><br><span class="line">-XX:MaxMetaspaceSize=N // 最大大小</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与永久代很大的不同就是，如果不指定大小的话，随着类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h5 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h5><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法等描述信息外，还有常量池信息。<br><strong>JDK1.7及之后版本JVM将运行时常量池从方法区中移出来，在Java堆中开辟了一块区域存放运行时常量池</strong></p>
<ul>
<li>常量池包含的内容<ul>
<li>字面量<ul>
<li>文本字符串</li>
<li>被声明为final的常量值</li>
<li>基本数据类型的值</li>
<li>其他</li>
</ul>
</li>
<li>符号引用<ul>
<li>类和结构的完全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符<br><img src="https://camo.githubusercontent.com/17620721a9f326a235aeec8956949cec03f3f125/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067" alt="image"><h5 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7.直接内存"></a>7.直接内存</h5>直接内存并不是虚拟机运行时的数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HotSpot虚拟机对象揭秘"><a href="#HotSpot虚拟机对象揭秘" class="headerlink" title="HotSpot虚拟机对象揭秘"></a>HotSpot虚拟机对象揭秘</h3><h5 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h5><p><img src="https://camo.githubusercontent.com/e99480df412dd718430d78094143a5485c908fa7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961343133353836393f773d39353026683d32373926663d706e6726733d3238353239" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类加载检查 -- 分配内存 -- 初始化零值 -- 设置对象头 -- 执行init方法</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1.1 类加载检查：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类型的符号引用，并且检查这个符号引用代表的类是否已被加载过，解析和初始化过，如果没有，那必须先执行相应的类加载过程</li>
<li>1.2 分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。分配方式有“指针碰撞”和“空间列表”两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
<li>1.3初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例在Java代码中可以不附初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>1.4 设置对象头：初始化零值完成后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等，这些信息存放在对象头中，另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li>1.5 执行init方法：在上述完成后，在虚拟机的角度看，新对象已经产生了，但是，Java程序来说，创建才刚开始，所有字段还为零，一般来说，执行new指令之后会接着执行init方法，把对象按照程序的意愿进行初始化，这样一个真正的对象才算完全产生出来。</li>
</ul>
<h4 id="2-对象的内存分布"><a href="#2-对象的内存分布" class="headerlink" title="2.对象的内存分布"></a>2.对象的内存分布</h4><p>在HotSpot中，对象在内存中的布局可以分为3块区域：对象头，实例数据和对齐填充</p>
<ul>
<li>对象头：包含两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码，GC分代年龄，锁状态表示等），第二部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针确定这个对象是那个类的实例。</li>
<li>实例数据部分：对象真正存储的有效信息</li>
<li>对齐填充部分：不是必然存在，也没特别的含义，仅仅占位作用<h5 id="3-对象的方位定位"><a href="#3-对象的方位定位" class="headerlink" title="3.对象的方位定位"></a>3.对象的方位定位</h5>建立对象就是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象。对象的方位方式有虚拟机实现而定，目前主流方式有：使用句柄、直接指针</li>
</ul>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/06/21/深入理解JVM/"></a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-06-21</span>
                
            </div>
            <div class="post-content">
                
                    <ol>
<li>运行时数据区域<ul>
<li>Java虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区</li>
</ul>
<ol>
<li>程序计数器<ul>
<li>程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域</li>
</ul>
</li>
<li>Java虚拟机栈<ul>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
<li>栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分</li>
<li>局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。 </li>
<li>Java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常 </li>
</ul>
</li>
<li>本地方法栈<ul>
<li>本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常</li>
</ul>
</li>
<li>Java堆<ul>
<li>堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配</li>
<li>Java堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代</li>
<li>不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存</li>
<li>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常</li>
</ul>
</li>
<li>方法区<ul>
<li>方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li>除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载</li>
<li>当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li>
<li>Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法</li>
<li>当常量池无法再申请到内存时会抛出OutOfMemoryError异常</li>
</ul>
</li>
</ol>
</li>
<li>HotSpot虚拟机对象<ol>
<li>对象创建<ul>
<li>检查：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</li>
<li>分配内存：接下来将为新生对象分配内存，为对象分配内存空间的任务等同于把一块确定的大小的内存从Java堆中划分出来<ul>
<li>假设Java堆中内存是绝对规整的，所有用过的内存放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做“指针碰撞”</li>
<li>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”</li>
<li>选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li>
</ul>
</li>
<li>Init: 执行new指令之后会接着执行Init方法，进行初始化，这样一个对象才算产生出来</li>
</ul>
</li>
<li>对象的内存布局（对象头，实例数据，对齐填充）<ul>
<li>对象头<ul>
<li>储存对象自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</li>
<li>另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例</li>
</ul>
</li>
</ul>
</li>
<li>对象访问定位<ul>
<li>使用句柄访问<ul>
<li>Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址</li>
<li>优势:reference中存储的是稳点的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改<br><img src="https://images2018.cnblogs.com/blog/687309/201804/687309-20180430172222987-651423543.jpg" alt="image">  </li>
</ul>
</li>
<li>使用直接指针访问<ul>
<li>Java堆对象的布局就必须考虑如何访问类型数据的相关信息,而refreence中存储的直接就是对象的地址</li>
<li>优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本<br><img src="https://images2018.cnblogs.com/blog/687309/201804/687309-20180430172234193-1261199664.jpg" alt="image"></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>OutOfMemoryError异常<ol>
<li>Java堆溢出<ul>
<li>Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置</li>
<li>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</li>
</ul>
</li>
<li>虚拟机栈和本地方法栈溢出<ul>
<li>对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</li>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常</li>
<li>在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常</li>
<li>如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程</li>
</ul>
</li>
<li>方法区和运行时常量池溢出<ul>
<li>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用</li>
<li>由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量</li>
<li>JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个</li>
</ul>
</li>
</ol>
</li>
<li>垃圾收集    <ol>
<li>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了</li>
<li>判断对象存活<ul>
<li>引用计数器法： 给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的</li>
<li>可达性分析算法：通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的<ul>
<li>Java语言中GC Roots的对象包括下面几种：<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI（Native方法）引用的对象</li>
</ul>
</li>
<li>引用<ul>
<li>强引用：在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</li>
<li>软引用：描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常</li>
<li>弱引用：描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象</li>
<li>虚引用：唯一目的就是能在这个对象被收集器回收时收到一个系统通知</li>
</ul>
</li>
<li>Finalize方法<ul>
<li>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>回收方法区<ul>
<li>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</li>
<li>废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池</li>
<li>无用的类：<ul>
<li>该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ul>
</li>
<li>垃圾收集算法<ul>
<li>标记-清除算法<ul>
<li>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</li>
<li>不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
</li>
<li>复制算法<ul>
<li>他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可</li>
<li>不足：将内存缩小为了原来的一半</li>
<li>实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor</li>
<li>当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</li>
</ul>
</li>
<li>标记-整理算法<ul>
<li>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li>
</ul>
</li>
<li>分代收集算法<ul>
<li>只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收</li>
</ul>
</li>
</ul>
</li>
<li>垃圾收集器<ul>
<li>Serial收集器<ul>
<li>这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个COU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</li>
</ul>
</li>
<li>ParNew收集器<ul>
<li>Serial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样</li>
<li>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li>
<li>并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上</li>
</ul>
</li>
<li>Parallel Scavenge<ul>
<li>一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器</li>
<li>吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</li>
</ul>
</li>
<li>Serial Old收集器<ul>
<li>Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法</li>
</ul>
</li>
<li>Parallel Old收集器<ul>
<li>Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法</li>
</ul>
</li>
<li>CMS收集器<ul>
<li>CMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
</li>
<li>优点：<ul>
<li>并发收集</li>
<li>低停顿</li>
</ul>
</li>
<li>缺点：<ul>
<li>CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4</li>
<li>CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生</li>
<li>CMS是基于标记清除算法实现的</li>
</ul>
</li>
</ul>
</li>
<li>G1收集器<ul>
<li>面向服务器应用的垃圾收集器</li>
<li>并行与并发：利用多CPU缩短STOP-The-World停顿的时间</li>
<li>分代收集</li>
<li>空间整合：不会产生内存碎片</li>
<li>可预测的停顿</li>
<li>运作方式：初始标记，并发标记，最终标记，筛选回收</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>内存分配与回收策略<ul>
<li>对象优先在Eden分配<ul>
<li>大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li>
</ul>
</li>
<li>大对象直接进入老年代<ul>
<li>所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制</li>
</ul>
</li>
<li>长期存活的对象将进入老年代<ul>
<li>如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中</li>
</ul>
</li>
<li>动态对象年龄判定<ul>
<li>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机类加载机制<ol>
<li>类加载时机<ul>
<li>类被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段</li>
<li>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以再初始化阶段之后再开始，这个是为了支持Java语言运行时绑定（也成为动态绑定或晚期绑定）</li>
<li>虚拟机规范规定有且只有5种情况必须立即对类进行初始化：<ul>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时候，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ul>
</li>
<li>被动引用<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li>
</ul>
</li>
<li>接口初始化<ul>
<li>接口在初始化时，并不要求其父接口全部完成类初始化，只有在正整使用到父接口的时候（如引用接口中定义的常量）才会初始化</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>类加载过程<ul>
<li>通过一个类的全限定名类获取定义此类的二进制字节流</li>
<li>将这字节流所代表的静态存储结构转化为方法区运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口<br><img src="https://upload-images.jianshu.io/upload_images/12219352-4bf6d1e14cc2897c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/468/format/webp" alt="image"></li>
</ul>
</li>
<li>类加载器种类<ul>
<li>启动类加载器，Bootstrap ClassLoader，加载JAVA_HOME\lib，或者被-Xbootclasspath参数限定类</li>
<li>扩展类加载器，Extension ClassLoader，加载\lib\ext，或者被java.ext.dirs系统变量指定的类</li>
<li>应用程序类加载器，Application ClassLoader，加载ClassPath中的类库</li>
<li>自定义类加载器，通过继承ClassLoader实现，一般是加载我们的自定义类双亲委派模型</li>
</ul>
</li>
<li>双亲委派模型<ul>
<li>展示的类加载器之间的这种层次关系,称为类加载器的双亲委派模型。类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的；除了启动类加载器，每个类都有其父类加载器（父子关系由组合（不是继承）来实现）</li>
<li>所谓双亲委派是指每次收到类加载请求时，先将请求委派给父类加载器完成（所有加载请求最终会委派到顶层的Bootstrap ClassLoader加载器中），如果父类加载器无法完成这个加载（该加载器的搜索范围中没有找到对应的类），子类尝试自己加载<br><img src="https://upload-images.jianshu.io/upload_images/12219352-52fd14e3e03944c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp" alt="image"></li>
</ul>
</li>
<li>如何获取二进制字节流<ul>
<li>从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础</li>
<li>从网络中获取，这种场景最典型的应用就是Applet</li>
<li>运行时计算生成，这种常见使用得最多的就是动态代理技术</li>
<li>由其他文件生成，典型场景就是JSP应用</li>
<li>从数据库中读取，这种场景相对少一些（中间件服务器）数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的</li>
</ul>
</li>
<li>验证<ul>
<li>文件格式验证<ul>
<li>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括：<ul>
<li>是否以魔数oxCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Itf8_info 型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
</ul>
</li>
<li>这个阶段的验证时基于二进制字节流进行的，只有通过类这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流</li>
</ul>
</li>
<li>元数据验证<ul>
<li>这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现类其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾(列如覆盖类父类的final字段,或者出现不符合规则的方法重载，列如方法参数都一致，但返回值类型却不同等)</li>
<li></li>
<li>第二阶段的主要目的是对类元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息</li>
</ul>
</li>
<li>字节码验证<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，列如在操作数栈放置类一个int类型的数据，使用时却按long类型来加载入本地变量表中</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换时有效的，列如可以把一个子类对象赋值给父类数据类型，这个是安全的，但是吧父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的</li>
</ul>
</li>
<li>符号引用验证<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到相对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可被当前类访问<br><img src="https://upload-images.jianshu.io/upload_images/12219352-4f7bb8b5789b3ad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350/format/webp" alt="image"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java内存模型和线程<ol>
<li>内存间的交互操作<br> <img src="https://images2018.cnblogs.com/blog/687309/201805/687309-20180501154120105-386717683.png" alt="image"><ul>
<li>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
</li>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，    如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存    模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，    store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺    序是read a，read b，load b， load a。</li>
<li>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
</ul>
</li>
</ul>
</li>
<li>重排序<ul>
<li>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
</li>
<li>对于volatile型变量的特殊规则<ul>
<li>第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
</li>
<li>第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</li>
</ul>
</li>
<li>对于long和double型变量的特殊规则<ul>
<li>Java模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64为的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为两次32为的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>线程安全<ol>
<li>线程安全的实现方法<ul>
<li>互斥同步<ul>
<li>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的</li>
<li>在Java中，最基本的互斥同步手段就是synchronized关键字，它经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有指明，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，对应的在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止</li>
<li>Synchronized，ReentrantLock增加了一些高级功能<ul>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁</li>
<li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition方法即可</li>
</ul>
</li>
</ul>
</li>
<li>非阻塞同步</li>
<li>无同步方案</li>
</ul>
</li>
</ol>
<ul>
<li>锁优化<ul>
<li>自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</li>
<li>自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。</li>
<li>锁消除：是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</li>
<li>锁粗化：如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</li>
<li>轻量级锁</li>
<li>偏向锁：它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS操作都不做了</li>
</ul>
</li>
</ul>
</li>
<li>线程逃逸<ol>
<li>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</li>
</ol>
</li>
</ol>
<p><a href="http://www.cnblogs.com/prayers/p/5515245.html" target="_blank" rel="noopener">参考文档</a><br><a href="https://www.cnblogs.com/jiangxiulian/p/7277960.html" target="_blank" rel="noopener">摘录</a></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/06/21/JDK8新特性/"></a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-06-21</span>
                
            </div>
            <div class="post-content">
                
                    <h5 id="1-接口默认方法（Default-Methods-for-Interfaces）"><a href="#1-接口默认方法（Default-Methods-for-Interfaces）" class="headerlink" title="1.接口默认方法（Default Methods for Interfaces）"></a>1.接口默认方法（Default Methods for Interfaces）</h5><ul>
<li><p>Java 8能够通过使用<code>default</code>关键字向接口添加非抽象方法实现，此功能成为<strong>虚拟扩展方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Formula&#123;</span><br><span class="line">    double calculate(int a);</span><br><span class="line">    default double sqrt(int a)&#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Formula接口中除了抽象方法计算接口公式还定义了默认方法<code>sqrt</code>。实现该接口的类只需要实现抽象方法<code>calculate</code>。默认方法<code>sqrt</code>可以直接使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Formula formula = new Formula()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public double calculate(int a)&#123;</span><br><span class="line">                return sqrt(a * 100);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(formula.calculate(100));</span><br><span class="line">        System.out.println(formula.sqrt(100));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-lambda表达式（lambda-expressions）"><a href="#2-lambda表达式（lambda-expressions）" class="headerlink" title="2.lambda表达式（lambda expressions）"></a>2.lambda表达式（lambda expressions）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenis&quot;);</span><br><span class="line">Collections.sort(names, new Comparator&lt;String&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String a, String b)&#123;</span><br><span class="line">        return b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Lambda表达式写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<h5 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3. 函数式接口"></a>3. 函数式接口</h5><ul>
<li>函数式接口值仅仅只包含一个抽象方法，但可以有多个非抽象方法（默认方法）的接口。</li>
<li>可以隐式转换成lambda表达式，java.lang.Runnable, java.util.concurrent.Callable。</li>
<li>@FunctionalIterface </li>
<li>只要接口包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Converter&lt;F, T&gt;&#123;</span><br><span class="line">    T convert(F form);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将数字类型转成整数类型</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (form) -&gt; Integer.valueOf(form);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Java8允许通过:: 关键字传递方法或构造函数的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 对象引用</span><br><span class="line">class Something &#123;</span><br><span class="line">    String startWith(String s)&#123;</span><br><span class="line">        return String.valueOf(s.charAt(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Something something = new Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startWith;</span><br><span class="line">String converted = converter.convert(&quot;Java&quot;);  // &quot;J&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数使用::关键字来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Person(String firstName, String lastName)&#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定一个用来创建Person对象的对象工厂接口</span><br><span class="line">interface PersonFactory&lt;P extends Persion&gt;&#123;</span><br><span class="line">    P create(String firstName, String lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用构造函数引用来讲他们关联起来</span><br><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::new; // 这里使用Person:new来获取Person类构造函数的引用</span><br><span class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda表达式作用域</p>
<ul>
<li><p>访问局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// final int num = 1;</span><br><span class="line">int num = 1; // 可以不用final修饰，但是后面不能修改num</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter = (form) -&gt; String.valueOf(form + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(2); // 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问字段和静态变量： 对lambda表达式中的实例字段和静态变量都有读写访问权限，和匿名对象一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Lambda4 &#123;</span><br><span class="line">    static int outerStaticNum;</span><br><span class="line">    int outerNum;</span><br><span class="line"></span><br><span class="line">    void testScopes() &#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = 23;</span><br><span class="line">            return String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = 72;</span><br><span class="line">            return String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方位默认接口方法： 无法从lambda表达中访问默认方法。</p>
<h5 id="5-内置函数式接口"><a href="#5-内置函数式接口" class="headerlink" title="5.内置函数式接口"></a>5.内置函数式接口</h5><p>JDK1.8中包含了许多内置函数式接口</p>
</li>
</ul>
</li>
<li>Predicates：只有一个参数的返回Boolean类型值的断言型接口。该接口包含许多默认方法将Predicate组合成其他复杂逻辑（与或非）</li>
<li>Optionals：用户防止NullPointerException的工具</li>
</ul>
<h5 id="6-Streams流"><a href="#6-Streams流" class="headerlink" title="6.Streams流"></a>6.Streams流</h5><ul>
<li>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。</li>
<li>Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行</li>
<li><p>过滤Filter</p>
<ul>
<li>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream()</span><br><span class="line">            .filter((s) -&gt; s.startWith(&apos;a&apos;))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    // forEach 是为 Lambda 而设计的，保持了最紧凑的风格</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Sorted(排序)</p>
<ul>
<li>排序是一个中间操作，返回排序后的Stream</li>
<li>排序只创建一个排列好的Stream，而不影响原有的数据源，排序之后原数据stringCollection不会被修改。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringList.stream()</span><br><span class="line">            .sorted()</span><br><span class="line">            .filter((s) -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">```   </span><br><span class="line">+ Map(映射)</span><br><span class="line">    - 中间操作map会将元素根据指定的Function接口来一次将元素转成另外的对象。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>stringList.stream()<br>            .map(String::toUpperCase)<br>            .sorted((a, b) -&gt; b.compareTo(a))<br>            .forEach(System.out::println);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ Match(匹配)</span><br><span class="line">    - Stream提供的匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，返回Boolean。</span><br></pre></td></tr></table></figure></p>
<p>boolean anyStartsWithA = stringList.stream()<br>                                    .anyMath((s)-&gt;s.startsWith(“a”)); // True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ Count(计数)</span><br><span class="line">    - 计数是一个最终操作，返回stream中元素的个数，返回类型是long。</span><br></pre></td></tr></table></figure></p>
<p>long startsWithB = stringList.stream()<br>                        .filter((s) -&gt; s.startsWith(“b”))<br>                        .count();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ Reduce(规约)</span><br><span class="line">    - 最终操作，允许通过指定的函数来将stream中的对各元素规约为一个元素。</span><br></pre></td></tr></table></figure></p>
<p>Optional<string> reduced = stringList.stream()<br>                        .sorted()<br>                        .reduce((s1, s2) -&gt; s1 + “#” + s2);<br>reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2<br><code>`</code></string></p>
<ul>
<li>Parallel Streams(并行流)</li>
<li>Sequential Sort(串行排序)</li>
<li>Parallel Sort(并行排序)</li>
<li>Maps</li>
<li>Date API</li>
<li></li>
<li>Annotations(注解)</li>
</ul>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/06/21/JDK动态代理和Cglib动态代理/"></a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-06-21</span>
                
            </div>
            <div class="post-content">
                
                    <h4 id="1-JDK动态代理"><a href="#1-JDK动态代理" class="headerlink" title="1. JDK动态代理"></a>1. JDK动态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//用户管理接口</span><br><span class="line">public interface UserManager &#123;</span><br><span class="line">    //新增用户抽象方法</span><br><span class="line">    void addUser(String userName,String password);</span><br><span class="line">    //删除用户抽象方法</span><br><span class="line">    void delUser(String userName);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用户管理实现类,实现用户管理接口</span><br><span class="line">public class UserManagerImpl implements UserManager&#123;</span><br><span class="line">    //重写新增用户方法</span><br><span class="line">    @Override</span><br><span class="line">    public void addUser(String userName, String password) &#123;</span><br><span class="line">        System.out.println(&quot;调用了新增的方法！&quot;);</span><br><span class="line">        System.out.println(&quot;传入参数为 userName: &quot;+userName+&quot; password: &quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line">    //重写删除用户方法</span><br><span class="line">    @Override</span><br><span class="line">    public void delUser(String userName) &#123;</span><br><span class="line">        System.out.println(&quot;调用了删除的方法！&quot;);</span><br><span class="line">        System.out.println(&quot;传入参数为 userName: &quot;+userName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//JDK动态代理实现InvocationHandler接口</span><br><span class="line">public class JdkProxy implements InvocationHandler &#123;</span><br><span class="line">    private Object target ;//需要代理的目标对象</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;JDK动态代理，监听开始！&quot;);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;JDK动态代理，监听结束！&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义获取代理对象方法</span><br><span class="line">    private Object getJDKProxy(Object targetObject)&#123;</span><br><span class="line">        //为目标对象target赋值</span><br><span class="line">        this.target = targetObject;</span><br><span class="line">        //JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出</span><br><span class="line">        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JdkProxy jdkProxy = new JdkProxy();//实例化JDKProxy对象</span><br><span class="line">        UserManager user = (UserManager) jdkProxy.getJDKProxy(new UserManagerImpl());//获取代理对象</span><br><span class="line">        user.addUser(&quot;admin&quot;, &quot;123123&quot;);//执行新增方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Cglib动态代理"><a href="#2-Cglib动态代理" class="headerlink" title="2. Cglib动态代理"></a>2. Cglib动态代理</h4><ul>
<li>依赖：asm-5.2.jar,cglib-3.2.5.jar<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//Cglib动态代理，实现MethodInterceptor接口</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Object target;//需要代理的目标对象</span><br><span class="line">    </span><br><span class="line">    //重写拦截方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] arr, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Cglib动态代理，监听开始！&quot;);</span><br><span class="line">        Object invoke = method.invoke(target, arr);//方法执行，参数：target 目标对象 arr参数数组</span><br><span class="line">        System.out.println(&quot;Cglib动态代理，监听结束！&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义获取代理对象方法</span><br><span class="line">    public Object getCglibProxy(Object objectTarget)&#123;</span><br><span class="line">        //为目标对象target赋值</span><br><span class="line">        this.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        //设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类</span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(this);// 设置回调 </span><br><span class="line">        Object result = enhancer.create();//创建并返回代理对象</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CglibProxy cglib = new CglibProxy();//实例化CglibProxy对象</span><br><span class="line">        UserManager user =  (UserManager) cglib.getCglibProxy(new UserManagerImpl());//获取代理对象</span><br><span class="line">        user.delUser(&quot;admin&quot;);//执行删除方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-代理模式："><a href="#3-代理模式：" class="headerlink" title="3.代理模式："></a>3.代理模式：</h4><ul>
<li><p>代理类和被代理类实现共同的接口（或继承），代理类中存有指向被代理类的索引，实际执行时通过调用代理类的方法、实际执行的是被代理类的方法。<br><img src="https://images2017.cnblogs.com/blog/1276132/201711/1276132-20171112204552606-1344033088.png" alt="image"></p>
</li>
<li><p>而AOP，是通过动态代理实现的。</p>
</li>
<li><p>简单来说：</p>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）</li>
</ul>
</li>
<li><p>Spring在选择用JDK还是CGLiB的依据：</p>
<ul>
<li>当Bean实现接口时，Spring就会用JDK的动态代理</li>
<li>当Bean没有实现接口时，Spring使用CGlib是实现</li>
<li>可以强制使用CGlib（在spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;）</li>
</ul>
</li>
<li><p>CGlib比JDK快？</p>
<ul>
<li>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。</li>
<li>在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</li>
</ul>
</li>
</ul>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/04/Nginx基本知识/">Nginx基本功能和原理</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-04</span>
                
            </div>
            <div class="post-content">
                
                    <h4 id="Nginx基本功能"><a href="#Nginx基本功能" class="headerlink" title="Nginx基本功能"></a>Nginx基本功能</h4><ul>
<li>反向代理</li>
<li>正向代理</li>
<li>负载均衡</li>
<li>HTTP服务器</li>
</ul>
                    <div class="read-more">
                        <a href="/2019/04/04/Nginx基本知识/" class="read-more-link">
                            阅读全文
                            <i class="iconfont icon-readmore"></i>
                        </a>
                    </div>
                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/04/为什么使用Nginx/">为什么使用Nginx</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-04</span>
                
            </div>
            <div class="post-content">
                
                    <p>Nginx是一个高性能的web和反向代理服务器，它具有很多优越的特性：</p>
<ul>
<li>作为web服务器，使用资源少，并发高</li>
<li>做负载均衡服务器</li>
<li>作为偶见代理服务器，</li>
<li>安装简单，配置文件简洁
                    <div class="read-more">
                        <a href="/2019/04/04/为什么使用Nginx/" class="read-more-link">
                            阅读全文
                            <i class="iconfont icon-readmore"></i>
                        </a>
                    </div>
                
            </li></ul></div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/04/Nginx配置/">Nginx配置</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-04</span>
                
            </div>
            <div class="post-content">
                
                    <h4 id="Nginx配置文件区域说明"><a href="#Nginx配置文件区域说明" class="headerlink" title="Nginx配置文件区域说明"></a>Nginx配置文件区域说明</h4>
                    <div class="read-more">
                        <a href="/2019/04/04/Nginx配置/" class="read-more-link">
                            阅读全文
                            <i class="iconfont icon-readmore"></i>
                        </a>
                    </div>
                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/02/Mybatis工作原理/">Mybatis工作原理</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-02</span>
                
            </div>
            <div class="post-content">
                
                    <h4 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h4><ul>
<li>Mybatis应用程序通过SQLSessionFactoryBuilder从mybatis-config.xml配置文件（也可以用Java文件配置的方式，需要添加@Configuration）中构建出SQLSessionFactory（SQLSessionFactory是县城安全的）
                    <div class="read-more">
                        <a href="/2019/04/02/Mybatis工作原理/" class="read-more-link">
                            阅读全文
                            <i class="iconfont icon-readmore"></i>
                        </a>
                    </div>
                
            </li></ul></div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/01/MyBatis基础（一）/">MyBatis基础知识</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-01</span>
                
            </div>
            <div class="post-content">
                
                    <h4 id="1-什么是Mybatis？"><a href="#1-什么是Mybatis？" class="headerlink" title="1.什么是Mybatis？"></a>1.什么是Mybatis？</h4><ul>
<li>Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发只需要关注SQL本身，不需要处理加载驱动，创建连接，创建statement等过程。
                    <div class="read-more">
                        <a href="/2019/04/01/MyBatis基础（一）/" class="read-more-link">
                            阅读全文
                            <i class="iconfont icon-readmore"></i>
                        </a>
                    </div>
                
            </li></ul></div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/03/30/Hexo+Github博客搭建/">hexo+github博客搭建</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-03-30</span>
                
            </div>
            <div class="post-content">
                
                    <p>使用Hexo搭建一个简单的博客<br>
                    <div class="read-more">
                        <a href="/2019/03/30/Hexo+Github博客搭建/" class="read-more-link">
                            阅读全文
                            <i class="iconfont icon-readmore"></i>
                        </a>
                    </div>
                
            </p></div>
        </article>
    
</div>
<div class="paginator">
    
        
        
        <a class="next" href="/page/2/">
            下一页
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2019
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">John Doe</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
